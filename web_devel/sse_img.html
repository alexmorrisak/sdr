<!DOCTYPE HTML>
<html>
   <head>
      <meta charset="utf-8"/>
      <style>
      body {
        background-color: lightgrey;
        margin: auto
      }
      h1 {
        font-size: large;
        color: black;
        margin: auto
      }

      </style>
   </head>
   <body>
     <h1>Test Spectrogram using Web Sockets </h1>
     <div id="result"></div>
     <canvas id="xyCanvas" width="512" height="200" style="border:1px solid #000000;">
     </canvas>

     <br>

     <canvas id="imgCanvas" width="512" height="400" style="border:1px solid #000000;">
     </canvas>
     <script>
     //var bstart = document.getElementById("startButton");
     //var bstop = document.getElementById("stopButton");
     var c = document.getElementById("imgCanvas");
     var ctx = c.getContext("2d");
     var c = document.getElementById("xyCanvas");
     var xyctx = c.getContext("2d");
     xyctx.fillStyle = "#9ea7b8";
     xyctx.globalCompositeOperation = "copy";
     var imagex = 512;
     var imagey = 400;
     var imageData = ctx.createImageData(imagex,imagey);
     var data = imageData.data;
     var socket_di;
     var imy = 400;

     document.getElementById("xyCanvas").style.backgroundColor = "white";
     document.getElementById("imgCanvas").style.backgroundColor = "lightblue";


     function Create2DArray(rows) {
       var arr = [];
     
       for (var i=0;i<rows;i++) {
          arr[i] = [];
       }
     
       return arr;
     }

     function getFloatArray(blob, nelements, offset) {
       var arr = [];
     
       for (var i=0;i<nelements;i++) {
          arr[i] = dv.getFloat32(offset+i);
       }
     
       return arr;
     }

     function get_appropriate_ws_url()
     {
       var pcol;
       var u = document.URL;
     
       /*
        * We open the websocket encrypted if this page came on an
        * https:// url itself, otherwise unencrypted
        */
     
       if (u.substring(0, 5) == "https") {
         pcol = "wss://";
         u = u.substr(8);
       } else {
         pcol = "ws://";
         if (u.substring(0, 4) == "http")
           u = u.substr(7);
       }
     
       u = u.split('/');
     
       /* + "/xxx" bit is for IE10 workaround */
     
       return pcol + u[0] + "/xxx";
     }

     dataBuff = Create2DArray(16);
     var ir = 0;
     var queue = 0;
     var dataCum = [];
     var oldDataCum = [];
     var insy = [];


     if (typeof MozWebSocket != "undefined") {
       socket_di = new MozWebSocket(get_appropriate_ws_url(),
              "dumb-increment-protocol");
     } else {
       socket_di = new WebSocket(get_appropriate_ws_url(),
              "dumb-increment-protocol");
     }

     try {
       socket_di.onopen = function() {
         console.log("opened socket\n");
       }

       var numBufs;
       var tmpBuf = [];
       socket_di.onmessage = function got_packet(msg) {
         tmpBuf = msg.data.split(" ");
         numBufs = 1*tmpBuf[0];
         //console.log("got %i chucnks\n", numBufs);
         for (var ib=0; ib<numBufs; ib++){
           for (var ix = 1; ix < imagex; ix+=1) {
             dataBuff[ib][ix] = 20*tmpBuf[ib*256+ix]-1900;

             if (queue==0) {
               dataCum[ix] = dataBuff[ir][ix];
             }
             else {
               dataCum[ix] += dataBuff[ir][ix];
             }
           }
           if (queue < 15) {queue += 1};
         }
       }
       function plot_data() {
         for (var x=0; x<imagex; x+=1) {
           insy[x] = dataCum[x] / queue;
           if (queue == 0) {
             insy[x] = oldDataCum[x];
           }
           oldDataCum[x] = insy[x];
           insy[x] = insy[x] - 400;
         }
         imy = ((imy - 1) % imagey + imagey) % imagey;
         //console.log("imy: %i\n", imy);
         for (var y = imy; y<imy+1; y+=1) {
           for (var x = 0; x<imagex; x+=1) {
             /*modify image data array*/
             var i = 4*(imagex*y + x);
             data[i]  = .3*(insy[x]+800);     // red
             data[i+1] = .2*(insy[x]+800);
             data[i+2] = 500-.4*(insy[x]+800);
             data[i+3] = 255; // transparency

           }
         }
         ctx.putImageData(imageData, 0, -imy, 0, imy,     imagex, 400-imy);
         ctx.putImageData(imageData, 0, 400-imy,  0, 0, imagex, imy);

         /* Draw new line */
         xyctx.beginPath();
         xyctx.moveTo(0,0);
         for (var x = 0; x<(imagex-1); x+=1) {
             //Draw x-y plot
             xyctx.lineTo(x+1, 99-.1*insy[x]);
         }
         xyctx.strokeStyle = '#000000';
         xyctx.lineWidth = 1;
         xyctx.stroke();

         //document.getElementById("result").innerHTML = dataBuff[ir][0];
         //document.getElementById("result").innerHTML = ir;
         document.getElementById("result").innerHTML = queue;
         //document.getElementById("result").innerHTML = numBufs;

         console.log("numBufs: %i", numBufs);
         //console.log("imy: %i", imy);
         //window.requestAnimationFrame(plot_data);
         queue = 0;
       }

       socket_di.onclose = function(){
       }
       //window.requestAnimationFrame(plot_data);
       setInterval(plot_data, 50);
     } catch(exception) {
       alert('<p>Error' + exception);
     }

     //}
     //);

     </script>

   </body>
</html>
